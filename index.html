<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Modern Digger - Basic</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Arial', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: #fff;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      touch-action: manipulation;
    }
    
    .container {
      width: 100%;
      max-width: 800px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    
    .screen {
      background: rgba(25, 25, 45, 0.9);
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      padding: 20px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 15px;
      background: linear-gradient(45deg, #ffd166, #ff6b6b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: 800;
    }
    
    h2 {
      font-size: 1.5rem;
      margin-bottom: 10px;
      color: #ffd166;
    }
    
    .subtitle {
      font-size: 1rem;
      max-width: 500px;
      margin-bottom: 20px;
      color: #b0b0d0;
      line-height: 1.4;
    }
    
    .btn {
      background: linear-gradient(45deg, #4ecdc4, #2a9d8f);
      color: white;
      border: none;
      padding: 12px 30px;
      font-size: 1rem;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      margin: 8px 0;
      width: 180px;
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
    }
    
    .btn:active {
      transform: translateY(1px);
    }
    
    .btn.fire {
      background: linear-gradient(45deg, #ff6b6b, #e63946);
    }
    
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 600px;
      background: #0c1021;
      border-radius: 8px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    canvas {
      display: block;
      width: 100%;
      image-rendering: pixelated;
    }
    
    #hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 10px;
      background: rgba(30, 30, 50, 0.7);
      border-radius: 8px;
      margin-bottom: 10px;
      font-size: 0.9rem;
    }
    
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      width: 100%;
      margin-top: 15px;
    }
    
    .arrow-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(50, 50, 80, 0.8);
      border: 2px solid #4ecdc4;
      color: white;
      font-size: 1.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .arrow-btn:active {
      background: rgba(78, 205, 196, 0.8);
    }
    
    #fireButton {
      width: 80px;
      height: 80px;
      font-size: 1.2rem;
      font-weight: bold;
    }
    
    .hidden {
      display: none !important;
    }
    
    @media (max-width: 600px) {
      .container {
        padding: 5px;
      }
      
      .screen {
        padding: 15px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 0.9rem;
        width: 160px;
      }
      
      .arrow-btn {
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
      }
      
      #fireButton {
        width: 70px;
        height: 70px;
      }
    }
    
    @media (orientation: landscape) {
      .container {
        flex-direction: row;
        align-items: flex-start;
        padding-top: 20px;
      }
      
      #gameContainer {
        max-width: 500px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Start Screen -->
    <div id="startScreen" class="screen">
      <h1>MODERN DIGGER</h1>
      <div class="subtitle">
        Dig through the terrain, collect emeralds, and avoid enemies in this modern twist on the classic game!
      </div>
      <button id="startButton" class="btn">START GAME</button>
      <div class="subtitle">
        Use arrow keys or touch controls to move. Spacebar or Fire button to shoot.
      </div>
    </div>
    
    <!-- Game Screen -->
    <div id="gameScreen" class="screen hidden">
      <h2>LEVEL <span id="levelDisplay">1</span></h2>
      
      <div id="hud">
        <div id="scoreDisplay">SCORE: 0</div>
        <div id="livesDisplay">LIVES: 3</div>
        <div id="emeraldsDisplay">EMERALDS: 0/5</div>
      </div>
      
      <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
      </div>
      
      <div id="controls">
        <button id="fireButton" class="btn fire">FIRE</button>
        <div style="display: flex; flex-direction: column; align-items: center;">
          <button id="upBtn" class="arrow-btn">↑</button>
          <div>
            <button id="leftBtn" class="arrow-btn">←</button>
            <button id="rightBtn" class="arrow-btn">→</button>
          </div>
          <button id="downBtn" class="arrow-btn">↓</button>
        </div>
      </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="endScreen" class="screen hidden">
      <h1 id="endTitle">GAME OVER</h1>
      <div id="endMessage" class="subtitle" style="font-size: 1.2rem; margin: 20px 0;"></div>
      <button id="restartButton" class="btn">PLAY AGAIN</button>
    </div>
  </div>

  <script>
    // Game Constants
    const CELL_SIZE = 40;
    const PLAYER_SPEED = 5;
    const ENEMY_SPEED = 2;
    const BULLET_SPEED = 8;
    const LEVELS = [
      { emeralds: 5, enemies: 1, enemySpeed: 2 },  // Level 1
      { emeralds: 7, enemies: 2, enemySpeed: 2.5 }, // Level 2
      { emeralds: 10, enemies: 3, enemySpeed: 3 }   // Level 3
    ];

    // Game Elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('startScreen');
    const gameScreen = document.getElementById('gameScreen');
    const endScreen = document.getElementById('endScreen');
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');
    const emeraldsDisplay = document.getElementById('emeraldsDisplay');
    const levelDisplay = document.getElementById('levelDisplay');
    const endTitle = document.getElementById('endTitle');
    const endMessage = document.getElementById('endMessage');

    // Game State
    let gameActive = false;
    let score = 0;
    let lives = 3;
    let currentLevel = 0;
    let emeraldsCollected = 0;
    let terrain = [];
    let emeralds = [];
    let enemies = [];
    let bullets = [];
    let cols, rows;

    // Player Object
    const player = {
      x: CELL_SIZE * 2,
      y: CELL_SIZE * 2,
      width: CELL_SIZE - 8,
      height: CELL_SIZE - 8,
      dx: 0,
      dy: 0,
      lastDirection: { x: 1, y: 0 },
      speed: PLAYER_SPEED,
      canShoot: true,
      color: '#FFD166'
    };

    // Initialize Game
    function initGame() {
      // Set canvas size based on device
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Event Listeners
      startButton.addEventListener('click', startGame);
      restartButton.addEventListener('click', startGame);
      
      // Touch controls
      document.getElementById('upBtn').addEventListener('touchstart', () => player.dy = -player.speed);
      document.getElementById('upBtn').addEventListener('touchend', () => player.dy = 0);
      document.getElementById('downBtn').addEventListener('touchstart', () => player.dy = player.speed);
      document.getElementById('downBtn').addEventListener('touchend', () => player.dy = 0);
      document.getElementById('leftBtn').addEventListener('touchstart', () => player.dx = -player.speed);
      document.getElementById('leftBtn').addEventListener('touchend', () => player.dx = 0);
      document.getElementById('rightBtn').addEventListener('touchstart', () => player.dx = player.speed);
      document.getElementById('rightBtn').addEventListener('touchend', () => player.dx = 0);
      document.getElementById('fireButton').addEventListener('touchstart', fireBullet);
      
      // Keyboard controls
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
    }

    function resizeCanvas() {
      // Adjust canvas size based on screen orientation
      const maxWidth = Math.min(600, window.innerWidth - 40);
      const maxHeight = window.innerHeight - 300;
      
      // Calculate grid size that fits the screen
      const calculatedCols = Math.floor(maxWidth / CELL_SIZE);
      const calculatedRows = Math.floor(maxHeight / CELL_SIZE);
      
      // Ensure we have at least 10x10 grid
      cols = Math.max(10, calculatedCols);
      rows = Math.max(10, calculatedRows);
      
      canvas.width = cols * CELL_SIZE;
      canvas.height = rows * CELL_SIZE;
      
      // Redraw if game is active
      if (gameActive) {
        drawGame();
      }
    }

    function startGame() {
      startScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');
      endScreen.classList.add('hidden');
      
      // Reset game state
      gameActive = true;
      score = 0;
      lives = 3;
      currentLevel = 0;
      emeraldsCollected = 0;
      
      // Initialize level
      initLevel();
      
      // Update HUD
      updateHUD();
      
      // Start game loop
      requestAnimationFrame(gameLoop);
    }

    function initLevel() {
      // Reset arrays
      terrain = [];
      emeralds = [];
      enemies = [];
      bullets = [];
      
      // Initialize terrain (all solid)
      for (let r = 0; r < rows; r++) {
        terrain[r] = [];
        for (let c = 0; c < cols; c++) {
          terrain[r][c] = true;
        }
      }
      
      // Create a winding tunnel from left to right
      createWindingTunnel();
      
      // Place player at start of tunnel
      player.x = CELL_SIZE;
      player.y = Math.floor(rows/2) * CELL_SIZE;
      player.dx = 0;
      player.dy = 0;
      
      // Spawn emeralds
      spawnEmeralds(LEVELS[currentLevel].emeralds);
      
      // Spawn enemies
      for (let i = 0; i < LEVELS[currentLevel].enemies; i++) {
        spawnEnemy();
      }
      
      // Update level display
      levelDisplay.textContent = currentLevel + 1;
      emeraldsDisplay.textContent = `EMERALDS: 0/${LEVELS[currentLevel].emeralds}`;
    }

    function createWindingTunnel() {
      // Create a winding tunnel that ensures enemies can always reach player
      let tunnelY = Math.floor(rows / 2);
      const directionChanges = Math.floor(cols / 10);
      
      for (let c = 0; c < cols; c++) {
        // Clear tunnel path
        terrain[tunnelY][c] = false;
        terrain[tunnelY+1][c] = false;
        
        // Random direction changes
        if (c % 10 === 0 && c > 0 && c < cols - 10) {
          const dir = Math.random() > 0.5 ? 1 : -1;
          const steps = Math.floor(Math.random() * 3) + 1;
          
          for (let s = 0; s < steps; s++) {
            tunnelY = Math.max(2, Math.min(rows-3, tunnelY + dir));
            terrain[tunnelY][c+s] = false;
            terrain[tunnelY+1][c+s] = false;
          }
        }
      }
    }

    function spawnEmeralds(count) {
      for (let i = 0; i < count; i++) {
        let placed = false;
        let attempts = 0;
        
        while (!placed && attempts < 100) {
          const col = Math.floor(Math.random() * cols);
          const row = Math.floor(Math.random() * rows);
          
          if (terrain[row][col] && !emeralds.some(e => e.col === col && e.row === row)) {
            emeralds.push({
              col,
              row,
              x: col * CELL_SIZE + CELL_SIZE/4,
              y: row * CELL_SIZE + CELL_SIZE/4,
              width: CELL_SIZE/2,
              height: CELL_SIZE/2,
              collected: false,
              color: '#06D6A0'
            });
            placed = true;
          }
          attempts++;
        }
      }
    }

    function spawnEnemy() {
      // Find a position that has a clear path to player
      let placed = false;
      let attempts = 0;
      
      while (!placed && attempts < 100) {
        const col = Math.floor(Math.random() * (cols - 10)) + 5;
        const row = Math.floor(Math.random() * (rows - 5)) + 2;
        
        if (!terrain[row][col] && hasPathToPlayer(col, row)) {
          enemies.push({
            x: col * CELL_SIZE + 5,
            y: row * CELL_SIZE + 5,
            width: CELL_SIZE - 10,
            height: CELL_SIZE - 10,
            speed: LEVELS[currentLevel].enemySpeed,
            dx: 0,
            dy: 0,
            color: '#EF476F',
            type: currentLevel > 1 ? 'hobbin' : 'nobbin'
          });
          placed = true;
        }
        attempts++;
      }
    }

    function hasPathToPlayer(enemyCol, enemyRow) {
      // Simple pathfinding check to ensure enemy can reach player
      const playerCol = Math.floor(player.x / CELL_SIZE);
      const playerRow = Math.floor(player.y / CELL_SIZE);
      
      // Check if there's a direct horizontal or vertical path
      if (enemyRow === playerRow) {
        const step = enemyCol < playerCol ? 1 : -1;
        for (let c = enemyCol; c !== playerCol; c += step) {
          if (terrain[enemyRow][c]) return false;
        }
        return true;
      }
      
      if (enemyCol === playerCol) {
        const step = enemyRow < playerRow ? 1 : -1;
        for (let r = enemyRow; r !== playerRow; r += step) {
          if (terrain[r][enemyCol]) return false;
        }
        return true;
      }
      
      return false;
    }

    function updatePlayer(deltaTime) {
      // Update position
      player.x += player.dx * deltaTime;
      player.y += player.dy * deltaTime;
      
      // Boundary checks
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
      
      // Update direction
      if (player.dx !== 0 || player.dy !== 0) {
        player.lastDirection = {
          x: player.dx !== 0 ? Math.sign(player.dx) : 0,
          y: player.dy !== 0 ? Math.sign(player.dy) : 0
        };
      }
      
      // Dig terrain at player position
      const col = Math.floor((player.x + player.width/2) / CELL_SIZE);
      const row = Math.floor((player.y + player.height/2) / CELL_SIZE);
      
      if (row >= 0 && row < rows && col >= 0 && col < cols && terrain[row][col]) {
        terrain[row][col] = false;
      }
      
      // Collect emeralds
      emeralds.forEach(emerald => {
        if (!emerald.collected && isColliding(player, emerald)) {
          emerald.collected = true;
          emeraldsCollected++;
          score += 10;
          updateHUD();
          
          // Check level completion
          if (emeraldsCollected >= LEVELS[currentLevel].emeralds) {
            completeLevel();
          }
        }
      });
    }

    function updateEnemies(deltaTime) {
      enemies.forEach((enemy, index) => {
        // Simple AI: Move towards player
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          enemy.dx = (dx / dist) * enemy.speed;
          enemy.dy = (dy / dist) * enemy.speed;
        }
        
        // Apply movement
        enemy.x += enemy.dx * deltaTime;
        enemy.y += enemy.dy * deltaTime;
        
        // Collision with player
        if (isColliding(player, enemy)) {
          lives--;
          updateHUD();
          
          if (lives <= 0) {
            gameOver();
          } else {
            // Respawn player
            player.x = CELL_SIZE;
            player.y = Math.floor(rows/2) * CELL_SIZE;
          }
          
          enemies.splice(index, 1);
        }
      });
    }

    function updateBullets(deltaTime) {
      bullets.forEach((bullet, index) => {
        // Apply movement
        bullet.x += bullet.dx * deltaTime;
        bullet.y += bullet.dy * deltaTime;
        
        // Boundary check
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          bullets.splice(index, 1);
          return;
        }
        
        // Check collision with terrain
        const col = Math.floor(bullet.x / CELL_SIZE);
        const row = Math.floor(bullet.y / CELL_SIZE);
        
        if (row >= 0 && row < rows && col >= 0 && col < cols && terrain[row][col]) {
          bullets.splice(index, 1);
          return;
        }
        
        // Check collision with enemies
        enemies.forEach((enemy, eIndex) => {
          if (isColliding(bullet, enemy)) {
            bullets.splice(index, 1);
            enemies.splice(eIndex, 1);
            score += 20;
            updateHUD();
          }
        });
      });
    }

    function fireBullet() {
      if (!player.canShoot) return;
      
      bullets.push({
        x: player.x + player.width/2 - 4,
        y: player.y + player.height/2 - 4,
        width: 8,
        height: 8,
        dx: player.lastDirection.x * BULLET_SPEED,
        dy: player.lastDirection.y * BULLET_SPEED,
        color: '#118AB2'
      });
      
      player.canShoot = false;
      setTimeout(() => player.canShoot = true, 300);
    }

    function isColliding(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function updateHUD() {
      scoreDisplay.textContent = `SCORE: ${score}`;
      livesDisplay.textContent = `LIVES: ${lives}`;
      emeraldsDisplay.textContent = `EMERALDS: ${emeraldsCollected}/${LEVELS[currentLevel].emeralds}`;
    }

    function completeLevel() {
      currentLevel++;
      
      if (currentLevel >= LEVELS.length) {
        // Game completed
        endTitle.textContent = "YOU WIN!";
        endMessage.textContent = `Final Score: ${score}`;
        gameOver();
      } else {
        // Start next level
        emeraldsCollected = 0;
        initLevel();
      }
    }

    function gameOver() {
      gameActive = false;
      gameScreen.classList.add('hidden');
      endScreen.classList.remove('hidden');
    }

    function drawGame() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw terrain
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (terrain[r][c]) {
            ctx.fillStyle = '#8B4513'; // Dirt
            ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          } else {
            ctx.fillStyle = '#C2B280'; // Tunnel
            ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
          }
        }
      }
      
      // Draw emeralds
      emeralds.forEach(emerald => {
        if (!emerald.collected) {
          ctx.fillStyle = emerald.color;
          ctx.beginPath();
          ctx.ellipse(
            emerald.x + emerald.width/2,
            emerald.y + emerald.height/2,
            emerald.width/2,
            emerald.height/2,
            0, 0, Math.PI * 2
          );
          ctx.fill();
        }
      });
      
      // Draw enemies
      enemies.forEach(enemy => {
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        
        // Draw eyes to indicate type
        ctx.fillStyle = '#000';
        ctx.fillRect(enemy.x + 8, enemy.y + 8, 6, 6);
        ctx.fillRect(enemy.x + enemy.width - 14, enemy.y + 8, 6, 6);
        
        if (enemy.type === 'hobbin') {
          // Draw angry eyebrows for hobbins
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(enemy.x + 6, enemy.y + 6);
          ctx.lineTo(enemy.x + 12, enemy.y + 4);
          ctx.moveTo(enemy.x + enemy.width - 12, enemy.y + 4);
          ctx.lineTo(enemy.x + enemy.width - 6, enemy.y + 6);
          ctx.stroke();
        }
      });
      
      // Draw bullets
      bullets.forEach(bullet => {
        ctx.fillStyle = bullet.color;
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
      });
      
      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
      
      // Draw player face
      ctx.fillStyle = '#000';
      const eyeX = player.lastDirection.x > 0 ? player.x + player.width - 12 : player.x + 6;
      ctx.fillRect(eyeX, player.y + 8, 6, 6);
      ctx.fillRect(eyeX + (player.lastDirection.x > 0 ? -12 : 12), player.y + 8, 6, 6);
    }

    function handleKeyDown(e) {
      switch (e.key) {
        case "ArrowUp":
          player.dy = -player.speed;
          break;
        case "ArrowDown":
          player.dy = player.speed;
          break;
        case "ArrowLeft":
          player.dx = -player.speed;
          break;
        case "ArrowRight":
          player.dx = player.speed;
          break;
        case " ":
          fireBullet();
          break;
      }
    }

    function handleKeyUp(e) {
      switch (e.key) {
        case "ArrowUp":
        case "ArrowDown":
          player.dy = 0;
          break;
        case "ArrowLeft":
        case "ArrowRight":
          player.dx = 0;
          break;
      }
    }

    function gameLoop(timestamp) {
      if (!gameActive) return;
      
      // Calculate delta time for smooth movement
      const deltaTime = 1; // Simplified for this basic version
      
      // Update game state
      updatePlayer(deltaTime);
      updateEnemies(deltaTime);
      updateBullets(deltaTime);
      
      // Draw everything
      drawGame();
      
      // Continue game loop
      requestAnimationFrame(gameLoop);
    }

    // Start the game when page loads
    window.addEventListener('load', initGame);
  </script>
</body>
</html>
